// This file is part of RogueVillage, a roguelike game.
//
// RogueVillage is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// RogueVillage is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with RogueVillage.  If not, see <https://www.gnu.org/licenses/>.

extern crate rand;
extern crate sdl2;

use std::collections::HashMap;
use std::collections::HashSet;
use std::f32;
use rand::Rng;

#[derive(Debug, Clone, Hash, Eq, PartialEq, Copy)]
pub enum Tile {
	Blank,
	Wall,
	WoodWall,
	Door(bool),
	Tree,
	Dirt,
	Grass,
	Player((u8, u8, u8)),
	Water,
	DeepWater,
	WorldEdge,
	Sand,
	Mountain,
	SnowPeak,
	Gate,
	StoneFloor,
	Creature((u8, u8, u8), char), // ie., NPC or item so far,
	Thing((u8, u8, u8), char), // ie., NPC or item so far,
	Separator,
	Bullet(char),
	Lava,
	FirePit,
	OldFirePit,
	Floor,
	Window(char),
	Spring,
    Portal,
    Fog,
	BoulderTrap((u8, u8, u8), bool, bool, (usize, usize), (i32, i32)),
	StairsUp,
	StairsDown,
}

impl Tile {
	pub fn is_clear(&self) -> bool {
		match self {
			Tile::Wall | Tile::Blank | Tile::Mountain | Tile::SnowPeak |
			Tile::Door(false) | Tile::WoodWall => false,
			_ => true,
		}
	}

	pub fn is_passable(&self) -> bool {
		match self {
			Tile::Wall | Tile::Blank | Tile::WorldEdge |
			Tile::Mountain | Tile::SnowPeak | Tile::Gate | Tile::Door(false) |
			Tile::WoodWall | Tile::Window(_) => false,		
			_ => true,
		}
	}
}

// Probably at some point in the dev process, I'll need to begin 
// storing the map in a struct with extra info instead of just
// a matrix of Tiles. Then, I won't have to recalculate height and
// width every time I call the in_bounds() method
pub fn in_bounds(map: &Vec<Vec<Tile>>, r: i32, c: i32) -> bool {
	let height = map.len() as i32;
	let width = map[0].len() as i32;

	r >= 0 && c >= 0 && r < height && c < width
}

// The caves generated by the cellular automata method can end up disjoint --
// ie., smaller caves separated from each other. First, we need to group the
// floor squares together into sets (or equivalence classes? Is that the term?) 
// using a Disjoint Set ADT.
//
// I'm going to treat squares as adjacent only if they are adjacent along the 
// 4 cardinal compass points.
// 
// To join caves, I look for any wall squares that are separating two different
// caves, then remove them. After that, I'll fill in any smaller caves that are
// still disjoint. (In testing, this still results in decent sized maps. And 
// filling them in means when placing dungeon featuers I can assume any two floor
// squares remaining are accessible from each other.
fn cave_qa(grid: &mut Vec<Vec<bool>>, width: usize, depth: usize) {
	let mut ds = find_isolated_caves(grid, width, depth);

	// Okay, my method to join rooms is to look for single walls that
	// are separating two caves, remove them, and union the two sets.
	// After that I'll fill in any smaller leftover caves
	for r in 1..depth - 1 {
		for c in 1..width - 1 {
			if !grid[r][c] { continue; }
			let i = (r * width + c) as i32;
			let mut adj_sets = HashSet::new();	
			let mut nf = false;
			let mut sf = false;
			let mut ef = false;
			let mut wf = false;

			if !grid[r - 1][c] { 
				adj_sets.insert(ds_find(&ds, i - width as i32));
				nf = true;
			}
						
			if !grid[r + 1][c] { 
				adj_sets.insert(ds_find(&ds, i + width as i32));
				sf = true;
			}

			if !grid[r][c - 1] { 
				adj_sets.insert(ds_find(&ds, i - 1));
				wf = true;
			}

			if !grid[r][c + 1] { 
				adj_sets.insert(ds_find(&ds, i + 1));
				ef = true;
			}

			if adj_sets.len() > 1 {
				grid[r][c] = false;
				if nf { ds_union(&mut ds, i, i - width as i32); }
				if sf { ds_union(&mut ds, i, i + width as i32); }
				if wf { ds_union(&mut ds, i, i - 1); }
				if ef { ds_union(&mut ds, i, i + 1); }
			}
		}
	}

	let sets = find_sets(grid, &mut ds, width, depth);
	let mut largest_set = 0;
	let mut largest_count = 0;
	for s in sets {
		if s.1 > largest_count { 
			largest_set = s.0; 
			largest_count = s.1;
		}
	}

	for r in 1..depth - 1 {
		for c in 1..width - 1 {
			if grid[r][c] { continue; }
			let set = ds_find(&ds, (r * width + c) as i32);
			if set != largest_set {
				grid[r][c] = true;
			}
		}
	}
}

fn count_neighbouring_walls(grid: &Vec<Vec<bool>>, row: i32, col: i32, width: i32, depth: i32) -> u32 {
	let mut adj_walls = 0;

	for r in -1..2 {
		for c in -1..2 {
			let nr = row + r;
			let nc = col + c;
			if nr < 0 || nc < 0 || nr == depth || nc == width {
				adj_walls += 1;
			} else if !(nr == 0 && nc == 0) && grid[nr as usize][nc as usize] {
				adj_walls += 1;
			}
		}
	}	

	adj_walls
}

pub fn generate_cave(width: usize, depth: usize) -> Vec<Vec<Tile>> {
	let mut grid = vec![vec![true; width]; depth];

	// Set some initial squares to be floors (false indidcates floor in our
	// initial grid)
	for r in 0..depth {
		for c in 0..width {
			let x: f64 = rand::thread_rng().gen();
			if x < 0.55 {
				grid[r][c] = false;
			}
		}
	}

	// We are using the 4-5 rule here (if a square has
	// 3 or fewer adjacents walls, it starves and becomes a floor,
	// if it has greater than 5 adj walls, it becomes a wall, otherwise
	// we leave it alone.
	//
	// One generation seems to generate nice enough maps!
	let mut next_gen = vec![vec![false; width]; depth];
	for r in 1..depth - 1 {
		for c in 1..width - 1 {
			let adj_walls = count_neighbouring_walls(&grid, r as i32, c as i32, width as i32, depth as i32);

			if adj_walls < 4 {
				next_gen[r][c] = false;
			} else if adj_walls > 5 {
				next_gen[r][c] = true;
			} else {
				next_gen[r][c] = grid[r][c];
			}
		}
	}

	// set the border
	for c in 0..width {
		next_gen[0][c] = true;
		next_gen[depth - 1][c] = true;	
	}
	for r in 1..depth - 1 {
		next_gen[r][0] = true;
		next_gen[r][width - 1] = true;
	}

	cave_qa(&mut next_gen, width, depth);

	let mut map: Vec<Vec<Tile>> = Vec::new();
	for r in next_gen {
		let mut row = Vec::new();
		for sq in r {
			let tile = if sq {
				Tile::Wall
			} else {
				Tile::StoneFloor
			};
			row.push(tile);
		}
		map.push(row);
	}
	
	map
}
